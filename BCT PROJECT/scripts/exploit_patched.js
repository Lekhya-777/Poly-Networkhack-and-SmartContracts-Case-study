import pkg from "hardhat";
const { ethers } = pkg;

async function main() {
  const signers = await ethers.getSigners();
  const funder = signers[0];
  const attacker = signers[1];

  // create owner wallet and fund it
  const ownerWallet = ethers.Wallet.createRandom().connect(ethers.provider);
  await funder.sendTransaction({ to: ownerWallet.address, value: ethers.parseEther("1") });

  // Deploy PatchedBridge with owner = ownerWallet.address
  const PB = await ethers.getContractFactory("PatchedBridge");
  const patched = await PB.connect(ownerWallet).deploy(ownerWallet.address);
  await patched.waitForDeployment();

  console.log("=== TESTING PATCHED BRIDGE SECURITY ===");
  console.log("Owner address:", ownerWallet.address);
  console.log("Attacker address:", attacker.address);
  console.log("PatchedBridge deployed at:", patched.target);

  // Fund the bridge
  await funder.sendTransaction({ to: patched.target, value: ethers.parseEther("10") });

  const amount = 10n;
  const messageHash = ethers.keccak256(ethers.solidityPacked(["address", "uint256"], [attacker.address, amount]));

  // Use the SAME RAW signature the owner would have produced (no prefix)
  const sigObj = ownerWallet.signingKey.sign(messageHash);
  const rawSignature = ethers.Signature.from(sigObj).serialized;

  console.log("Message hash (raw):", messageHash);
  console.log("Forged RAW signature (no prefix):", rawSignature);
  console.log("Attempting forged withdraw on patched contract...");

  // Attacker calls withdraw with the raw signature - patched contract expects prefixed digest so this should revert
  try {
    const tx = await patched.connect(attacker).withdraw(amount, rawSignature);
    await tx.wait();
    console.log("❌ SECURITY FAILURE! Withdraw on patched contract succeeded unexpectedly!");
  } catch (err) {
    console.log("✅ Withdraw rejected as expected. PatchedBridge prevents naive forgery.");
  }

  const attackerBalAfter = Number(ethers.formatEther(await ethers.provider.getBalance(attacker.address)));
  const bridgeBalAfter = Number(ethers.formatEther(await ethers.provider.getBalance(patched.target)));
  console.log("Attacker balance after:", attackerBalAfter);
  console.log("Bridge balance after:", bridgeBalAfter);
}

main().catch((err) => { console.error(err); process.exit(1); });
